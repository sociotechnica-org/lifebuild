/**
 * Tests for JWT utilities
 */

import { describe, it, expect } from 'vitest'
import {
  isTokenExpired,
  isWithinGracePeriod,
  decodeJWTPayload,
  getUserIdFromToken,
} from '../../src/auth/jwt.js'

// Mock JWT for testing (this would be generated by auth service in reality)
const createMockJWT = (payload: any): Promise<string> => {
  // This is a simplified JWT creation for testing
  // In reality, use the auth service to create real JWTs
  const header = { alg: 'HS256', typ: 'JWT' }
  const headerEncoded = btoa(JSON.stringify(header)).replace(/=/g, '')
  const payloadEncoded = btoa(JSON.stringify(payload)).replace(/=/g, '')

  // For testing, we'll use a simple signature
  return Promise.resolve(`${headerEncoded}.${payloadEncoded}.test-signature`)
}

describe('JWT utilities', () => {
  describe('decodeJWTPayload', () => {
    it('should decode valid JWT payload', async () => {
      const payload = {
        userId: 'test-user-123',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      const token = await createMockJWT(payload)
      const decoded = decodeJWTPayload(token)

      expect(decoded).toBeDefined()
      expect(decoded?.userId).toBe(payload.userId)
      expect(decoded?.email).toBe(payload.email)
    })

    it('should return null for invalid token format', () => {
      const result = decodeJWTPayload('invalid-token')
      expect(result).toBeNull()
    })

    it('should return null for malformed token', () => {
      const result = decodeJWTPayload('header.payload')
      expect(result).toBeNull()
    })
  })

  describe('getUserIdFromToken', () => {
    it('should extract userId from valid token', async () => {
      const payload = {
        userId: 'user-456',
        email: 'user@example.com',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      const token = await createMockJWT(payload)
      const userId = getUserIdFromToken(token)

      expect(userId).toBe('user-456')
    })

    it('should return null for invalid token', () => {
      const userId = getUserIdFromToken('invalid')
      expect(userId).toBeNull()
    })
  })

  describe('isTokenExpired', () => {
    it('should return false for valid token', () => {
      const payload = {
        userId: 'test-user',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      expect(isTokenExpired(payload)).toBe(false)
    })

    it('should return true for expired token', () => {
      const payload = {
        userId: 'test-user',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000) - 7200, // 2 hours ago
        exp: Math.floor(Date.now() / 1000) - 3600, // 1 hour ago
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      expect(isTokenExpired(payload)).toBe(true)
    })

    it('should respect grace period', () => {
      const payload = {
        userId: 'test-user',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000) - 3600,
        exp: Math.floor(Date.now() / 1000) - 1800, // 30 minutes ago
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      // Without grace period - should be expired
      expect(isTokenExpired(payload, 0)).toBe(true)

      // With 1 hour grace period - should not be expired
      expect(isTokenExpired(payload, 3600)).toBe(false)
    })
  })

  describe('isWithinGracePeriod', () => {
    it('should return true for valid tokens', () => {
      const payload = {
        userId: 'test-user',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      expect(isWithinGracePeriod(payload, 3600)).toBe(true)
    })

    it('should return true for tokens within grace period', () => {
      const payload = {
        userId: 'test-user',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000) - 3600,
        exp: Math.floor(Date.now() / 1000) - 1800, // 30 minutes ago
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      // With 1 hour grace period
      expect(isWithinGracePeriod(payload, 3600)).toBe(true)
    })

    it('should return false for tokens beyond grace period', () => {
      const payload = {
        userId: 'test-user',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000) - 7200,
        exp: Math.floor(Date.now() / 1000) - 3600, // 1 hour ago
        iss: 'work-squared-auth',
        workspaces: [],
        workspaceClaimsIssuedAt: Math.floor(Date.now() / 1000),
        workspaceClaimsVersion: 1,
      }

      // With 30 minute grace period
      expect(isWithinGracePeriod(payload, 1800)).toBe(false)
    })
  })

  // Note: verifyJWT tests would require actual JWT implementation
  // These are covered by integration tests with the auth service
})
